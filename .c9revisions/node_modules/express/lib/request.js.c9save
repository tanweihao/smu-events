{"ts":1382091088003,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"\n/**\n * Module dependencies.\n */\n\nvar http = require('http')\n  , utils = require('./utils')\n  , connect = require('connect')\n  , fresh = require('fresh')\n  , parseRange = require('range-parser')\n  , parse = connect.utils.parseUrl\n  , mime = connect.mime;\n\n/**\n * Request prototype.\n */\n\nvar req = exports = module.exports = {\n  __proto__: http.IncomingMessage.prototype\n};\n\n/**\n * Return request header.\n *\n * The `Referrer` header field is special-cased,\n * both `Referrer` and `Referer` are interchangeable.\n *\n * Examples:\n *\n *     req.get('Content-Type');\n *     // => \"text/plain\"\n *\n *     req.get('content-type');\n *     // => \"text/plain\"\n *\n *     req.get('Something');\n *     // => undefined\n *\n * Aliased as `req.header()`.\n *\n * @param {String} name\n * @return {String}\n * @api public\n */\n\nreq.get =\nreq.header = function(name){\n  switch (name = name.toLowerCase()) {\n    case 'referer':\n    case 'referrer':\n      return this.headers.referrer\n        || this.headers.referer;\n    default:\n      return this.headers[name];\n  }\n};\n\n/**\n * Check if the given `type(s)` is acceptable, returning\n * the best match when true, otherwise `undefined`, in which\n * case you should respond with 406 \"Not Acceptable\".\n *\n * The `type` value may be a single mime type string\n * such as \"application/json\", the extension name\n * such as \"json\", a comma-delimted list such as \"json, html, text/plain\",\n * or an array `[\"json\", \"html\", \"text/plain\"]`. When a list\n * or array is given the _best_ match, if any is returned.\n *\n * Examples:\n *\n *     // Accept: text/html\n *     req.accepts('html');\n *     // => \"html\"\n *\n *     // Accept: text/*, application/json\n *     req.accepts('html');\n *     // => \"html\"\n *     req.accepts('text/html');\n *     // => \"text/html\"\n *     req.accepts('json, text');\n *     // => \"json\"\n *     req.accepts('application/json');\n *     // => \"application/json\"\n *\n *     // Accept: text/*, application/json\n *     req.accepts('image/png');\n *     req.accepts('png');\n *     // => undefined\n *\n *     // Accept: text/*;q=.5, application/json\n *     req.accepts(['html', 'json']);\n *     req.accepts('html, json');\n *     // => \"json\"\n *\n * @param {String|Array} type(s)\n * @return {String}\n * @api public\n */\n\nreq.accepts = function(type){\n  return utils.accepts(type, this.get('Accept'));\n};\n\n/**\n * Check if the given `encoding` is accepted.\n *\n * @param {String} encoding\n * @return {Boolean}\n * @api public\n */\n\nreq.acceptsEncoding = function(encoding){\n  return ~this.acceptedEncodings.indexOf(encoding);\n};\n\n/**\n * Check if the given `charset` is acceptable,\n * otherwise you should respond with 406 \"Not Acceptable\".\n *\n * @param {String} charset\n * @return {Boolean}\n * @api public\n */\n\nreq.acceptsCharset = function(charset){\n  var accepted = this.acceptedCharsets;\n  return accepted.length\n    ? ~accepted.indexOf(charset)\n    : true;\n};\n\n/**\n * Check if the given `lang` is acceptable,\n * otherwise you should respond with 406 \"Not Acceptable\".\n *\n * @param {String} lang\n * @return {Boolean}\n * @api public\n */\n\nreq.acceptsLanguage = function(lang){\n  var accepted = this.acceptedLanguages;\n  return accepted.length\n    ? ~accepted.indexOf(lang)\n    : true;\n};\n\n/**\n * Parse Range header field,\n * capping to the given `size`.\n *\n * Unspecified ranges such as \"0-\" require\n * knowledge of your resource length. In\n * the case of a byte range this is of course\n * the total number of bytes. If the Range\n * header field is not given `null` is returned,\n * `-1` when unsatisfiable, `-2` when syntactically invalid.\n *\n * NOTE: remember that ranges are inclusive, so\n * for example \"Range: users=0-3\" should respond\n * with 4 users when available, not 3.\n *\n * @param {Number} size\n * @return {Array}\n * @api public\n */\n\nreq.range = function(size){\n  var range = this.get('Range');\n  if (!range) return;\n  return parseRange(size, range);\n};\n\n/**\n * Return an array of encodings.\n *\n * Examples:\n *\n *     ['gzip', 'deflate']\n *\n * @return {Array}\n * @api public\n */\n\nreq.__defineGetter__('acceptedEncodings', function(){\n  var accept = this.get('Accept-Encoding');\n  return accept\n    ? accept.trim().split(/ *, */)\n    : [];\n});\n\n/**\n * Return an array of Accepted media types\n * ordered from highest quality to lowest.\n *\n * Examples:\n *\n *     [ { value: 'application/json',\n *         quality: 1,\n *         type: 'application',\n *         subtype: 'json' },\n *       { value: 'text/html',\n *         quality: 0.5,\n *         type: 'text',\n *         subtype: 'html' } ]\n *\n * @return {Array}\n * @api public\n */\n\nreq.__defineGetter__('accepted', function(){\n  var accept = this.get('Accept');\n  return accept\n    ? utils.parseAccept(accept)\n    : [];\n});\n\n/**\n * Return an array of Accepted languages\n * ordered from highest quality to lowest.\n *\n * Examples:\n *\n *     Accept-Language: en;q=.5, en-us\n *     ['en-us', 'en']\n *\n * @return {Array}\n * @api public\n */\n\nreq.__defineGetter__('acceptedLanguages', function(){\n  var accept = this.get('Accept-Language');\n  return accept\n    ? utils\n      .parseParams(accept)\n      .map(function(obj){\n        return obj.value;\n      })\n    : [];\n});\n\n/**\n * Return an array of Accepted charsets\n * ordered from highest quality to lowest.\n *\n * Examples:\n *\n *     Accept-Charset: iso-8859-5;q=.2, unicode-1-1;q=0.8\n *     ['unicode-1-1', 'iso-8859-5']\n *\n * @return {Array}\n * @api public\n */\n\nreq.__defineGetter__('acceptedCharsets', function(){\n  var accept = this.get('Accept-Charset');\n  return accept\n    ? utils\n      .parseParams(accept)\n      .map(function(obj){\n        return obj.value;\n      })\n    : [];\n});\n\n/**\n * Return the value of param `name` when present or `defaultValue`.\n *\n *  - Checks route placeholders, ex: _/user/:id_\n *  - Checks body params, ex: id=12, {\"id\":12}\n *  - Checks query string params, ex: ?id=12\n *\n * To utilize request bodies, `req.body`\n * should be an object. This can be done by using\n * the `connect.bodyParser()` middleware.\n *\n * @param {String} name\n * @param {Mixed} [defaultValue]\n * @return {String}\n * @api public\n */\n\nreq.param = function(name, defaultValue){\n  var params = this.params || {};\n  var body = this.body || {};\n  var query = this.query || {};\n  if (null != params[name] && params.hasOwnProperty(name)) return params[name];\n  if (null != body[name]) return body[name];\n  if (null != query[name]) return query[name];\n  return defaultValue;\n};\n\n/**\n * Check if the incoming request contains the \"Content-Type\"\n * header field, and it contains the give mime `type`.\n *\n * Examples:\n *\n *      // With Content-Type: text/html; charset=utf-8\n *      req.is('html');\n *      req.is('text/html');\n *      req.is('text/*');\n *      // => true\n *\n *      // When Content-Type is application/json\n *      req.is('json');\n *      req.is('application/json');\n *      req.is('application/*');\n *      // => true\n *\n *      req.is('html');\n *      // => false\n *\n * @param {String} type\n * @return {Boolean}\n * @api public\n */\n\nreq.is = function(type){\n  var ct = this.get('Content-Type');\n  if (!ct) return false;\n  ct = ct.split(';')[0];\n  if (!~type.indexOf('/')) type = mime.lookup(type);\n  if (~type.indexOf('*')) {\n    type = type.split('/');\n    ct = ct.split('/');\n    if ('*' == type[0] && type[1] == ct[1]) return true;\n    if ('*' == type[1] && type[0] == ct[0]) return true;\n    return false;\n  }\n  return !! ~ct.indexOf(type);\n};\n\n/**\n * Return the protocol string \"http\" or \"https\"\n * when requested with TLS. When the \"trust proxy\"\n * setting is enabled the \"X-Forwarded-Proto\" header\n * field will be trusted. If you're running behind\n * a reverse proxy that supplies https for you this\n * may be enabled.\n *\n * @return {String}\n * @api public\n */\n\nreq.__defineGetter__('protocol', function(){\n  var trustProxy = this.app.get('trust proxy');\n  return this.connection.encrypted\n    ? 'https'\n    : trustProxy\n      ? (this.get('X-Forwarded-Proto') || 'http')\n      : 'http';\n});\n\n/**\n * Short-hand for:\n *\n *    req.protocol == 'https'\n *\n * @return {Boolean}\n * @api public\n */\n\nreq.__defineGetter__('secure', function(){\n  return 'https' == this.protocol;\n});\n\n/**\n * Return the remote address, or when\n * \"trust proxy\" is `true` return\n * the upstream addr.\n *\n * @return {String}\n * @api public\n */\n\nreq.__defineGetter__('ip', function(){\n  return this.ips[0] || this.connection.remoteAddress;\n});\n\n/**\n * When \"trust proxy\" is `true`, parse\n * the \"X-Forwarded-For\" ip address list.\n *\n * For example if the value were \"client, proxy1, proxy2\"\n * you would receive the array `[\"client\", \"proxy1\", \"proxy2\"]`\n * where \"proxy2\" is the furthest down-stream.\n *\n * @return {Array}\n * @api public\n */\n\nreq.__defineGetter__('ips', function(){\n  var trustProxy = this.app.get('trust proxy');\n  var val = this.get('X-Forwarded-For');\n  return trustProxy && val\n    ? val.split(/ *, */)\n    : [];\n});\n\n/**\n * Return basic auth credentials.\n *\n * Examples:\n *\n *    // http://tobi:hello@example.com\n *    req.auth\n *    // => { username: 'tobi', password: 'hello' }\n *\n * @return {Object} or undefined\n * @api public\n */\n\nreq.__defineGetter__('auth', function(){\n  // missing\n  var auth = this.get('Authorization');\n  if (!auth) return;\n\n  // malformed\n  var parts = auth.split(' ');\n  if ('basic' != parts[0].toLowerCase()) return;\n  if (!parts[1]) return;\n  auth = parts[1];\n\n  // credentials\n  auth = new Buffer(auth, 'base64').toString().match(/^([^:]*):(.*)$/);\n  if (!auth) return;\n  return { username: auth[1], password: auth[2] };\n});\n\n/**\n * Return subdomains as an array.\n *\n * Subdomains are the dot-separated parts of the host before the main domain of\n * the app. By default, the domain of the app is assumed to be the last two\n * parts of the host. This can be changed by setting \"subdomain offset\".\n *\n * For example, if the domain is \"tobi.ferrets.example.com\":\n * If \"subdomain offset\" is not set, req.subdomains is `[\"ferrets\", \"tobi\"]`.\n * If \"subdomain offset\" is 3, req.subdomains is `[\"tobi\"]`.\n *\n * @return {Array}\n * @api public\n */\n\nreq.__defineGetter__('subdomains', function(){\n  var offset = this.app.get('subdomain offset');\n  return (this.host || '')\n    .split('.')\n    .reverse()\n    .slice(offset);\n});\n\n/**\n * Short-hand for `url.parse(req.url).pathname`.\n *\n * @return {String}\n * @api public\n */\n\nreq.__defineGetter__('path', function(){\n  return parse(this).pathname;\n});\n\n/**\n * Parse the \"Host\" header field hostname.\n *\n * @return {String}\n * @api public\n */\n\nreq.__defineGetter__('host', function(){\n  var trustProxy = this.app.get('trust proxy');\n  var host = trustProxy && this.get('X-Forwarded-Host');\n  host = host || this.get('Host');\n  if (!host) return;\n  return host.split(':')[0];\n});\n\n/**\n * Check if the request is fresh, aka\n * Last-Modified and/or the ETag\n * still match.\n *\n * @return {Boolean}\n * @api public\n */\n\nreq.__defineGetter__('fresh', function(){\n  var method = this.method;\n  var s = this.res.statusCode;\n\n  // GET or HEAD for weak freshness validation only\n  if ('GET' != method && 'HEAD' != method) return false;\n\n  // 2xx or 304 as per rfc2616 14.26\n  if ((s >= 200 && s < 300) || 304 == s) {\n    return fresh(this.headers, this.res._headers);\n  }\n\n  return false;\n});\n\n/**\n * Check if the request is stale, aka\n * \"Last-Modified\" and / or the \"ETag\" for the\n * resource has changed.\n *\n * @return {Boolean}\n * @api public\n */\n\nreq.__defineGetter__('stale', function(){\n  return !this.fresh;\n});\n\n/**\n * Check if the request was an _XMLHttpRequest_.\n *\n * @return {Boolean}\n * @api public\n */\n\nreq.__defineGetter__('xhr', function(){\n  var val = this.get('X-Requested-With') || '';\n  return 'xmlhttprequest' == val.toLowerCase();\n});\n"]],"start1":0,"start2":0,"length1":0,"length2":11658}]],"length":11658}
